<html>
	<body>
		<div id="container">
		</div>
		<script src="three.min.js"></script>
		<script src="OrbitAndPanControls.js"></script>
		<script src="dat.gui.min.js"></script>
		<script src="Coordinates.js"></script>
		<script>
			/*global THREE, window, document, $*/

			var camera, scene, renderer;
			var cameraControls, effectController;
			var clock = new THREE.Clock();
			var gridX = false;
			var gridY = false;
			var gridZ = false;
			var axes = false;
			var ground = false;
			var ambientLight, light;
			var toyTrain;

			var material = new THREE.MeshPhongMaterial( { color: 0x960f0b, shininess: 30 } );
			var ka = 0.4;
			material.ambient.setRGB( material.color.r * ka, material.color.g * ka, material.color.b * ka );

			function init() {
				var canvasWidth = 846;
				var canvasHeight = 494;
				// For grading the window is fixed in size; here's general code:
				//var canvasWidth = window.innerWidth;
				//var canvasHeight = window.innerHeight;
				var canvasRatio = canvasWidth / canvasHeight;

				// CAMERA

				camera = new THREE.PerspectiveCamera( 45, canvasRatio, 1, 80000 );
				camera.position.set( -300, 300, -1000 );
				camera.lookAt(0,0,0);
				// LIGHTS

				ambientLight = new THREE.AmbientLight( 0xFFFFFF );

				light = new THREE.DirectionalLight( 0xFFFFFF, 0.7 );
				light.position.set( -800, 900, 300 );

				// RENDERER
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setSize( canvasWidth, canvasHeight );
				//renderer.setClearColorHex( 0x1F42A3, 1.0 );
				renderer.setClearColorHex( 0xAAAAAA, 1.0 );

				var container = document.getElementById('container');
				container.appendChild( renderer.domElement );
				//document.body.appendChild(renderer.domElement);

				renderer.gammaInput = true;
				renderer.gammaOutput = true;

				// CONTROLS
				cameraControls = new THREE.OrbitAndPanControls( camera, renderer.domElement );
				cameraControls.target.set(0, 0, 0);
	
			}

			function createTrainEngine(ttEngine) {
				
				var cube = new THREE.Mesh( new THREE.CubeGeometry( 200,24,80 ), material )
				//var cube = new THREE.Mesh( new THREE.CubeGeometry( 500,60,200 ) )
				ttEngine.add( cube );
				
				var cube1 = new THREE.Mesh( new THREE.CubeGeometry( 100,80,80 ), material )
				//var cube1 = new THREE.Mesh( new THREE.CubeGeometry( 250,220,200 ) )
				cube1.position.y = 12+40;
				cube1.position.x = -50;
				ttEngine.add( cube1 );
				
				var roof = new THREE.Mesh( new THREE.CylinderGeometry( 10, 80, 50, 4, 10  ), material )
				//var roof = new THREE.Mesh( new THREE.CylinderGeometry( 0, 75, 225, 40, 10  ) )
				roof.position.y = 12+80+25;
				roof.position.x = -50;
				roof.rotation.y = 45*Math.PI/180;
				//cube1.position.x = -125;
				ttEngine.add( roof );
				
				//creating cylinder
				var cyl = new THREE.Mesh( new THREE.CylinderGeometry( 35, 35, 100, 40, 10 ), material );
				//var cyl = new THREE.Mesh( new THREE.CylinderGeometry( 90, 90, 380, 10, 10 ) );
				cyl.rotation.z = 90*Math.PI/180;
				cyl.position.y = 12+25;
				cyl.position.x = 40;
				ttEngine.add( cyl );
				
				//creating cylinder
				var frntRight = new THREE.Mesh( new THREE.CylinderGeometry( 24, 24, 8, 16, 10 ), material );
				frntRight.rotation.x = 90*Math.PI/180;
				frntRight.position.z = 40+4;
				frntRight.position.x = 50;
				ttEngine.add( frntRight );
				
				//creating cylinder
				var rareRight = new THREE.Mesh( new THREE.CylinderGeometry( 24, 24, 8, 16, 10 ), material );
				rareRight.rotation.x = 90*Math.PI/180;
				rareRight.position.z = 40+4;
				rareRight.position.x = -50;
				ttEngine.add( rareRight );
				
				//creating cylinder
				var frntLeft = new THREE.Mesh( new THREE.CylinderGeometry( 24, 24, 8, 16, 10 ), material );
				frntLeft.rotation.x = 90*Math.PI/180;
				frntLeft.position.z = -(40+4);
				frntLeft.position.x = 50;
				ttEngine.add( frntLeft );
				
				//creating cylinder
				var rareLeft = new THREE.Mesh( new THREE.CylinderGeometry( 24, 24, 8, 16, 10 ), material );
				rareLeft.rotation.x = 90*Math.PI/180;
				rareLeft.position.z = -(40+4);
				rareLeft.position.x = -50;
				ttEngine.add( rareLeft );
				
				//creating cylinder
				var chi = new THREE.Mesh( new THREE.CylinderGeometry( 20, 12, 24, 40, 10 ), material );
				//chi.rotation.x = 90*Math.PI/180;
				chi.position.y = 12+35+24;
				chi.position.x = 50;
				ttEngine.add( chi );
					
			}

			function createTrack(rad) {
				var trcInner = new THREE.Mesh( new THREE.TorusGeometry( rad, (rad*0.5/100), 6, 100 ), material );
				trcInner.rotation.x = 90*Math.PI/180;
				scene.add( trcInner );
				var trcOuter = new THREE.Mesh( new THREE.TorusGeometry( rad+85, (rad*0.5/100), 6, 100 ), material );
				trcOuter.rotation.x = 90*Math.PI/180;
				scene.add( trcOuter );
				//create track connector
				
				for ( i=0; i<=359; i=i+4) {
					var slab = new THREE.Mesh( new THREE.CubeGeometry( 100,2,20 ), material );
					slab.position.x = rad+(85/2);
					slab.position.y = 0;
					var slabRot = new THREE.Object3D();
					slabRot.add( slab );
					slabRot.rotation.y = i * Math.PI/180;
					scene.add(slabRot);
				}
				
				//var cube = new THREE.Mesh( new THREE.CubeGeometry( 500,60,200 ) )
				
			}
			
			function createTrain(toyTrain) {
				var radius = 650;
				var ttEngine = new THREE.Object3D();
				createTrainEngine(ttEngine);
				createTrack(radius);
				ttEngine.position.z = radius+40;
				ttEngine.position.y = 24;
				// add field for animated part, for simplicity
				toyTrain.animated = ttEngine;
				
				toyTrain.add(ttEngine);
			}

			function fillScene() {
				scene = new THREE.Scene();
				scene.fog = new THREE.Fog(  0x1F42A3, 4000, 8000 );
				//scene.fog = new THREE.Fog( 0x808080, 4000, 8000 );

				// LIGHTS
				scene.add( ambientLight );
				scene.add( light );

				//var ball = createBall();
				//scene.add( ball );
				toyTrain = new THREE.Object3D();
				createTrain( toyTrain );
				scene.add( toyTrain );
				//var box = createCube();
				//Coordinates.drawGround({size:10000});
				//scene.add( box );

				

				//Coordinates.drawGround({size:1000});
				//Coordinates.drawGrid({size:1000,scale:0.01});
				//Coordinates.drawAllAxes({axisLength:500,axisRadius:1,axisTess:4});
			}

			function addToDOM() {
				var container = document.getElementById('container');
				var canvas = container.getElementsByTagName('canvas');
				if (canvas.length>0) {
					container.removeChild(canvas[0]);
				}
				container.appendChild( renderer.domElement );
			}

			function animate() {

				window.requestAnimationFrame( animate );
				render();

			}

			function render() {
				var delta = clock.getDelta();
				cameraControls.update(delta);
				toyTrain.rotation.y += 0.5*Math.PI/180;
				toyTrain.rotation.z = (Math.random()*1.5)*Math.PI/180;
				if ( effectController.newGridX !== gridX || effectController.newGridY !== gridY ||effectController.newGridZ !== gridZ || effectController.newGround !== ground || effectController.newAxes !== axes)
				{
					gridX = effectController.newGridX;
					gridY = effectController.newGridY;
					gridZ = effectController.newGridZ;
					ground = effectController.newGround;
					axes = effectController.newAxes;

					fillScene();
					drawHelpers();
				}
				renderer.render( scene, camera );
			}

			function drawHelpers() {
				if (ground) {
					Coordinates.drawGround({size:10000});
				}
				if (gridX) {
					Coordinates.drawGrid({size:10000,scale:0.01});
				}
				if (gridY) {
					Coordinates.drawGrid({size:10000,scale:0.01, orientation:"y"});
				}
				if (gridZ) {
					Coordinates.drawGrid({size:10000,scale:0.01, orientation:"z"});
				}
				if (axes) {
					Coordinates.drawAllAxes({axisLength:200,axisRadius:1,axisTess:50});
				}
			}

			function setupGui() {
				effectController = {

					newGridX: gridX,
					newGridY: gridY,
					newGridZ: gridZ,
					newGround: ground,
					newAxes: axes
				};
				var gui = new dat.GUI();
				gui.add( effectController, "newGridX").name("Show XZ grid");
				gui.add( effectController, "newGridY" ).name("Show YZ grid");
				gui.add( effectController, "newGridZ" ).name("Show XY grid");
				gui.add( effectController, "newGround" ).name("Show ground");
				gui.add( effectController, "newAxes" ).name("Show axes");
			}
			try {
				init();
				fillScene();
				setupGui();
				drawHelpers();
				addToDOM();
				animate();
			} catch(e) {
				var errorReport = "Your program encountered an unrecoverable error, can not draw on canvas. Error was:<br/><br/>";
				//$('#container').append(errorReport+e);
			}

		</script>
	</body>
</html>
