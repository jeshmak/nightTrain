<html>
	<body>
		<div id="container">
		</div>
		<script src="lib/three.min.js"></script>
		<script src="lib/OrbitAndPanControls.js"></script>
		<script src="lib/dat.gui.min.js"></script>
		<script src="lib/Coordinates.js"></script>

		<script type="x-shader/x-vertex" id="vertexShader">
			varying vec3 vWorldPosition;
			void main() {
				vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
				vWorldPosition = worldPosition.xyz;
				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			}
		</script>
		<script type="x-shader/x-fragment" id="fragmentShader">
			uniform vec3 topColor;
			uniform vec3 bottomColor;
			uniform float offset;
			uniform float exponent;
			varying vec3 vWorldPosition;
			void main() {
				float h = normalize( vWorldPosition + offset ).y;
				gl_FragColor = vec4( mix( bottomColor, topColor, max( pow( max( h, 0.0 ), exponent ), 0.0 ) ), 1.0 );	
			}
		</script>
		<script>
			/*global THREE, window, document, $*/

			var camera, scene, renderer;
			var cameraControls, effectController;
			var clock = new THREE.Clock();
			var gridX = false;
			var gridY = false;
			var gridZ = false;
			var axes = false;
			var ground = false;
			var ambientLight, light, headlight;
			var toyTrain, ttEngine, ttCompt_01, ttCompt_02;
			var spriteMaterial, sprite;
			var smokeParticles = new THREE.Geometry;
			var time = 0;
			var ttEngine = new THREE.Object3D();

			var material = new THREE.MeshPhongMaterial( { color: 0x393939, specular: 0x2e2e2e, shininess: 30 } );
			var bluMat = new THREE.MeshPhongMaterial( { color: 0x3399ff, specular: 0x2e2e2e, shininess: 30 } );
			var redMat = new THREE.MeshPhongMaterial( { color: 0xff0000, specular: 0x2e2e2e, shininess: 30 } );
			var greenMat = new THREE.MeshPhongMaterial( { color: 0x009933, specular: 0x2e2e2e, shininess: 30 } );		
			var owhiteMat = new THREE.MeshPhongMaterial( { color: 0xffcccc, specular: 0x2e2e2e, shininess: 30 } );
			var yellowMat = new THREE.MeshPhongMaterial( { color: 0xffff99, specular: 0x2e2e2e, shininess: 30 } );
			var orngwMat = new THREE.MeshPhongMaterial( { color: 0xff9900, specular: 0x2e2e2e, shininess: 30 } );
			//var ka = 0.4;
			//material.ambient.setRGB( material.color.r * ka, material.color.g * ka, material.color.b * ka );

			function init() {
				//var canvasWidth = 846;
				//var canvasHeight = 494;
				// For grading the window is fixed in size; here's general code:
				var canvasWidth = window.innerWidth;
				var canvasHeight = window.innerHeight;
				var canvasRatio = canvasWidth / canvasHeight;

				// CAMERA

				camera = new THREE.PerspectiveCamera( 45, canvasRatio, 1, 80000 );
				camera.position.set( -300, 300, -1300 );
				//camera.position.set( -100, 300, -500 );
				//camera.rotation.y = -90*Math.PI*180;
				camera.lookAt(0,0,0);
				// LIGHTS

				//ambientLight = new THREE.AmbientLight( 0x232323 );
				ambientLight = new THREE.DirectionalLight( 0xFFFFFF, 0.5);
				ambientLight.position.set( 800, 900, -300 );

				light = new THREE.DirectionalLight( 0xFFFFFF, 1.0 );
				light.position.set( 0, 1, 1 );

				headlight = new THREE.PointLight( 0xFFFFFF, 0.5 );
				//headlight.position.set(1, 1, 1);
    				//scene.add( headlight );

				// RENDERER
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setSize( canvasWidth, canvasHeight );
				//renderer.setClearColorHex( 0x1F42A3, 1.0 );
				renderer.setClearColorHex( 0xAAAAAA, 1.0 );

				var container = document.getElementById('container');
				container.appendChild( renderer.domElement );
				//document.body.appendChild(renderer.domElement);

				renderer.gammaInput = true;
				renderer.gammaOutput = true;

				// CONTROLS
				cameraControls = new THREE.OrbitAndPanControls( camera, renderer.domElement );
				cameraControls.target.set(0, 0, 0);
			}
			
			function addSmoke() {
				//var smokeParticles = new THREE.Geometry;
				for (var i = 0; i<=100; i++) {
						//chi.position.y = 12+35+24;
						//chi.position.x = 50;
    						var particle = new THREE.Vector3(Math.random() * 30 - 15, Math.random() * 200, Math.random() * 30 - 15);
    						smokeParticles.vertices.push(particle);
					}
				var smokeTexture = THREE.ImageUtils.loadTexture('media/maple.png');
				//var smokeMaterial = new THREE.ParticleBasicMaterial({ map: smokeTexture, transparent: true, blending: THREE.AdditiveBlending, size: 50, color: 0x111111 });
				var smokeMaterial = new THREE.ParticleBasicMaterial({ map: smokeTexture, transparent: true, size: 60, color: 0x31B404});
				var smoke = new THREE.ParticleSystem(smokeParticles, smokeMaterial);
				smoke.position.x = 50;
				smoke.position.y = 71;
				smoke.sortParticles = true;
				//smoke.position.x = -150;
				smoke.sortParticles = 1;
				//scene.add(smoke);
				ttEngine.add( smoke );
			}
			
			function addStars() {
			
				var particleTexture = THREE.ImageUtils.loadTexture( 'media/particle.png' );

				particleGroup = new THREE.Object3D();
				particleAttributes = { pOpacity: [], startPosition: [], randomness: [] };
	
				var totalParticles = 2000;
				var radiusRange = 2500;
				for( var i = 0; i < totalParticles; i++ ) 
				{
					spriteMaterial = new THREE.SpriteMaterial( { map: particleTexture, useScreenCoordinates: false, color: 0xffffff } );
					var pSc = Math.random()*144;
					sprite = new THREE.Sprite( spriteMaterial );
					sprite.scale.set( pSc, pSc, 1.0 ); // imageWidth, imageHeight
					sprite.position.set( Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5 );
					// for a cube:
					// sprite.position.multiplyScalar( radiusRange );
					// for a solid sphere:
					// sprite.position.setLength( radiusRange * Math.random() );
					// for a spherical shell:
					sprite.position.setLength( radiusRange * (Math.random() * 0.1 + 1.0) );
		
					// sprite.color.setRGB( Math.random(),  Math.random(),  Math.random() ); 
					sprite.material.color.setHSL( Math.random(), 0.3, (Math.random())-0.5 ); 
		
					sprite.opacity = 0.0; // translucent particles
					sprite.material.blending = THREE.AdditiveBlending; // "glowing" particles
		
					particleGroup.add( sprite );
					// add variable qualities to arrays, if they need to be accessed later
					//particleAttributes.pOpacity.push( sprite.opacity.clone() );
					particleAttributes.startPosition.push( sprite.position.clone() );
					particleAttributes.randomness.push( Math.random() );
				}
				scene.add( particleGroup );	
			}
			
			function addSkyDome() {
				var vertexShader = document.getElementById( 'vertexShader' ).textContent;
				var fragmentShader = document.getElementById( 'fragmentShader' ).textContent;
				var uniforms = {
					topColor: 	 { type: "c", value: new THREE.Color( 0x070B19) },
					bottomColor: { type: "c", value: new THREE.Color( 0x0B173B ) },
					offset:		 { type: "f", value: 400 },
					exponent:	 { type: "f", value: 0.6 }
				}
				var skyGeo = new THREE.SphereGeometry( 4000, 32, 15 );
				var skyMat = new THREE.ShaderMaterial( { vertexShader: vertexShader, fragmentShader: fragmentShader, uniforms: uniforms, side: THREE.BackSide } );
				var sky = new THREE.Mesh( skyGeo, skyMat );
				scene.add( sky );
			}

			function createTrainEngine(ttEngine) {

				//HOOK
				var engHookCyl = new THREE.Mesh( new THREE.CylinderGeometry( 2, 2, 20, 16, 10 ), material );
				engHookCyl.position.x = -(100+10);
				//engHookCyl.position.y = -1;
				engHookCyl.rotation.z = 90*Math.PI/180;
				ttEngine.add( engHookCyl );
				var engHookTor = new THREE.Mesh( new THREE.TorusGeometry( 6, 1.6, 16, 100 ), material );
				engHookTor.position.x = -(100+14+6);
				//engHookTor.position.y = -1;
				engHookTor.rotation.x = 90*Math.PI/180;
				ttEngine.add( engHookTor );

				var cube = new THREE.Mesh( new THREE.CubeGeometry( 200,24,80 ), owhiteMat );
				ttEngine.add( cube );
				
				var cube1 = new THREE.Mesh( new THREE.CubeGeometry( 100,80,80 ), greenMat );
				//var cube1 = new THREE.Mesh( new THREE.CubeGeometry( 250,220,200 ) )
				cube1.position.y = 12+40;
				cube1.position.x = -50;
				ttEngine.add( cube1 );
				
				var roof = new THREE.Mesh( new THREE.CylinderGeometry( 10, 80, 50, 4, 10  ), orngwMat );
				//var roof = new THREE.Mesh( new THREE.CylinderGeometry( 0, 75, 225, 40, 10  ) )
				roof.position.y = 12+80+25;
				roof.position.x = -50;
				roof.rotation.y = 45*Math.PI/180;
				//cube1.position.x = -125;
				ttEngine.add( roof );
				
				//creating cylinder
				var cyl = new THREE.Mesh( new THREE.CylinderGeometry( 35, 35, 100, 40, 10 ), redMat );
				//var cyl = new THREE.Mesh( new THREE.CylinderGeometry( 90, 90, 380, 10, 10 ) );
				cyl.rotation.z = 90*Math.PI/180;
				cyl.position.y = 12+25;
				cyl.position.x = 40;
				ttEngine.add( cyl );
				
				//creating cylinder
				var frntRight = new THREE.Mesh( new THREE.CylinderGeometry( 24, 24, 8, 16, 10 ), bluMat );
				frntRight.rotation.x = 90*Math.PI/180;
				frntRight.position.z = 40+4;
				frntRight.position.x = 50;
				ttEngine.add( frntRight );
				
				//creating cylinder
				var rareRight = new THREE.Mesh( new THREE.CylinderGeometry( 24, 24, 8, 16, 10 ), bluMat );
				rareRight.rotation.x = 90*Math.PI/180;
				rareRight.position.z = 40+4;
				rareRight.position.x = -50;
				ttEngine.add( rareRight );
				
				//creating cylinder
				var frntLeft = new THREE.Mesh( new THREE.CylinderGeometry( 24, 24, 8, 16, 10 ), bluMat );
				frntLeft.rotation.x = 90*Math.PI/180;
				frntLeft.position.z = -(40+4);
				frntLeft.position.x = 50;
				ttEngine.add( frntLeft );
				
				//creating cylinder
				var rareLeft = new THREE.Mesh( new THREE.CylinderGeometry( 24, 24, 8, 16, 10 ), bluMat );
				rareLeft.rotation.x = 90*Math.PI/180;
				rareLeft.position.z = -(40+4);
				rareLeft.position.x = -50;
				ttEngine.add( rareLeft );
				
				//creating cylinder
				var chi = new THREE.Mesh( new THREE.CylinderGeometry( 20, 12, 24, 40, 10 ), yellowMat );
				//chi.rotation.x = 90*Math.PI/180;
				chi.position.y = 12+35+24;
				chi.position.x = 50;
				ttEngine.add( chi );
					
			}

			function addCompartment( ttCompt_01_pos, ttCompt_02_pos ) {
				//BASE - First Compartment
				var c1Base = new THREE.Mesh( new THREE.CubeGeometry( 200,24,80 ), owhiteMat );
				ttCompt_01_pos.add( c1Base );
				//HOOK
				
				var c1Hook = new THREE.Mesh( new THREE.CubeGeometry( 25,8,12 ), material );
				c1Hook.position.x = 100+12;
				c1Hook.position.y = -8;
				ttCompt_01_pos.add( c1Hook );
				var c1HookCyl = new THREE.Mesh( new THREE.CylinderGeometry( 2, 2, 10, 16, 10 ), material );
				c1HookCyl.position.x = 100+25-5;
				c1HookCyl.position.y = 1;
				ttCompt_01_pos.add( c1HookCyl );
				
				//WALLS
				var c1WallR = new THREE.Mesh( new THREE.CubeGeometry( 200,50,10 ), orngwMat );
				c1WallR .position.y = 12+25;
				c1WallR .position.z = 80/2-10/2;
				ttCompt_01_pos.add( c1WallR  );
				var c1WallL = new THREE.Mesh( new THREE.CubeGeometry( 200,50,10 ), orngwMat );
				c1WallL .position.y = 12+25;
				c1WallL .position.z = -(80/2-10/2);
				ttCompt_01_pos.add( c1WallL  );
				var c1WallF = new THREE.Mesh( new THREE.CubeGeometry( 10,50,60 ), orngwMat );
				c1WallF .position.y = 12+25;
				c1WallF .position.x = 200/2-10/2;
				ttCompt_01_pos.add( c1WallF  );	
				var c1WallR = new THREE.Mesh( new THREE.CubeGeometry( 10,50,60 ), orngwMat );
				c1WallR .position.y = 12+25;
				c1WallR .position.x = -(200/2-10/2);
				ttCompt_01_pos.add( c1WallR  );
				//WHEELS
				var c1WheelFR = new THREE.Mesh( new THREE.CylinderGeometry( 24, 24, 8, 16, 10 ), bluMat );
				c1WheelFR.rotation.x = 90*Math.PI/180;
				c1WheelFR.position.z = 40+4;
				c1WheelFR.position.x = 50;
				ttCompt_01_pos.add( c1WheelFR );
				var c1WheelRR = new THREE.Mesh( new THREE.CylinderGeometry( 24, 24, 8, 16, 10 ), bluMat );
				c1WheelRR.rotation.x = 90*Math.PI/180;
				c1WheelRR.position.z = 40+4;
				c1WheelRR.position.x = -50;
				ttCompt_01_pos.add( c1WheelRR );
				var c1WheelFL = new THREE.Mesh( new THREE.CylinderGeometry( 24, 24, 8, 16, 10 ), bluMat );
				c1WheelFL.rotation.x = 90*Math.PI/180;
				c1WheelFL.position.z = -(40+4);
				c1WheelFL.position.x = 50;
				ttCompt_01_pos.add( c1WheelFL );
				var c1WheelRL = new THREE.Mesh( new THREE.CylinderGeometry( 24, 24, 8, 16, 10 ), bluMat );
				c1WheelRL.rotation.x = 90*Math.PI/180;
				c1WheelRL.position.z = -(40+4);
				c1WheelRL.position.x = -50;
				ttCompt_01_pos.add( c1WheelRL );
				//B_HOOK
				var c1BHook = new THREE.Mesh( new THREE.CylinderGeometry( 2, 2, 20, 16, 10 ), material );
				c1BHook.position.x = -(100+10);
				//engHookCyl.position.y = -1;
				c1BHook.rotation.z = 90*Math.PI/180;
				ttCompt_01_pos.add( c1BHook );
				var c1BHookTor = new THREE.Mesh( new THREE.TorusGeometry( 6, 1.6, 16, 100 ), material );
				c1BHookTor.position.x = -(100+14+6);
				//engHookTor.position.y = -1;
				c1BHookTor.rotation.x = 90*Math.PI/180;
				ttCompt_01_pos.add( c1BHookTor );

				//HOOK - Second Compartment
				var c2Hook = new THREE.Mesh( new THREE.CubeGeometry( 25,8,12 ), material );
				ttCompt_02_pos.add( c2Hook );
				c2Hook.position.x = 100+12;
				c2Hook.position.y = -8;
				var c2HookCyl = new THREE.Mesh( new THREE.CylinderGeometry( 2, 2, 10, 16, 10 ), material );
				ttCompt_02_pos.add( c2HookCyl );
				c2HookCyl.position.x = 100+25-5;
				c2HookCyl.position.y = 1;
				//BASE 
				var c2Base = new THREE.Mesh( new THREE.CubeGeometry( 200,24,80 ), owhiteMat );
				ttCompt_02_pos.add( c2Base );
				//WALLS
				var c2WallR = new THREE.Mesh( new THREE.CubeGeometry( 200,50,10 ), redMat );
				c2WallR .position.y = 12+25;
				c2WallR .position.z = 80/2-10/2;
				ttCompt_02_pos.add( c2WallR  );
				var c2WallL = new THREE.Mesh( new THREE.CubeGeometry( 200,50,10 ), redMat );
				c2WallL .position.y = 12+25;
				c2WallL .position.z = -(80/2-10/2);
				ttCompt_02_pos.add( c2WallL  );
				var c2WallF = new THREE.Mesh( new THREE.CubeGeometry( 10,50,60 ), redMat );
				c2WallF .position.y = 12+25;
				c2WallF .position.x = 200/2-10/2;
				ttCompt_02_pos.add( c2WallF  );	
				var c2WallR = new THREE.Mesh( new THREE.CubeGeometry( 10,50,60 ), redMat );
				c2WallR .position.y = 12+25;
				c2WallR .position.x = -(200/2-10/2);
				ttCompt_02_pos.add( c2WallR  );
				//WHEELS
				var c2WheelFR = new THREE.Mesh( new THREE.CylinderGeometry( 24, 24, 8, 16, 10 ), bluMat );
				c2WheelFR.rotation.x = 90*Math.PI/180;
				c2WheelFR.position.z = 40+4;
				c2WheelFR.position.x = 50;
				ttCompt_02_pos.add( c2WheelFR );
				var c2WheelRR = new THREE.Mesh( new THREE.CylinderGeometry( 24, 24, 8, 16, 10 ), bluMat );
				c2WheelRR.rotation.x = 90*Math.PI/180;
				c2WheelRR.position.z = 40+4;
				c2WheelRR.position.x = -50;
				ttCompt_02_pos.add( c2WheelRR );
				var c2WheelFL = new THREE.Mesh( new THREE.CylinderGeometry( 24, 24, 8, 16, 10 ), bluMat );
				c2WheelFL.rotation.x = 90*Math.PI/180;
				c2WheelFL.position.z = -(40+4);
				c2WheelFL.position.x = 50;
				ttCompt_02_pos.add( c2WheelFL );
				var c2WheelRL = new THREE.Mesh( new THREE.CylinderGeometry( 24, 24, 8, 16, 10 ), bluMat );
				c2WheelRL.rotation.x = 90*Math.PI/180;
				c2WheelRL.position.z = -(40+4);
				c2WheelRL.position.x = -50;
				ttCompt_02_pos.add( c2WheelRL );
				
			}

			function createTrack(rad) {
				var trcInner = new THREE.Mesh( new THREE.TorusGeometry( rad, (rad*0.5/100), 6, 100 ), material );
				trcInner.rotation.x = 90*Math.PI/180;
				scene.add( trcInner );
				var trcOuter = new THREE.Mesh( new THREE.TorusGeometry( rad+85, (rad*0.5/100), 6, 100 ), material );
				trcOuter.rotation.x = 90*Math.PI/180;
				scene.add( trcOuter );
				//create track connector
				
				for ( i=0; i<=359; i=i+4) {
					var slab = new THREE.Mesh( new THREE.CubeGeometry( 100,2,20 ), material );
					slab.position.x = rad+(85/2);
					slab.position.y = 0;
					var slabRot = new THREE.Object3D();
					slabRot.add( slab );
					slabRot.rotation.y = i * Math.PI/180;
					scene.add(slabRot);
				}
				
				//var cube = new THREE.Mesh( new THREE.CubeGeometry( 500,60,200 ) )
				
			}
			
			function createTrain(toyTrain, ttCompt_01, ttCompt_02) {
				var radius = 650;
				//var ttEngine = new THREE.Object3D();
				createTrainEngine(ttEngine);
				createTrack(radius);
				
				ttEngine.position.z = radius+40;
				ttEngine.position.y = 24;

				// add field for animated part, for simplicity
				toyTrain.animated = ttEngine;
				
				toyTrain.add(ttEngine);
				
				var ttCompt_01_pos = new THREE.Object3D();
				var ttCompt_02_pos = new THREE.Object3D();
				
				addCompartment( ttCompt_01_pos, ttCompt_02_pos );
						
				ttCompt_01_pos.position.z = radius+40;
				//ttCompt_01_pos.position.x = -240;
				ttCompt_02_pos.position.z = radius+40;
				ttCompt_01_pos.position.y = 24;
				ttCompt_02_pos.position.y = 24;
				// add field for animated part, for simplicity
				ttCompt_01.animated = ttCompt_01_pos;
				ttCompt_02.animated = ttCompt_02_pos;									
				
				ttCompt_01.add(ttCompt_01_pos);
				ttCompt_02.add(ttCompt_02_pos);
				
			}

			function fillScene() {
				scene = new THREE.Scene();
				scene.fog = new THREE.Fog(  0x0B173B, 500, 2800 );

				// LIGHTS
				//scene.add( ambientLight );
				scene.add( light );
				scene.add( headlight );
				// Train
				toyTrain = new THREE.Object3D();
				ttCompt_01 = new THREE.Object3D();
				ttCompt_01.rotation.y = -20 * Math.PI/180;
				ttCompt_02 = new THREE.Object3D();
				ttCompt_02.rotation.y = -40 * Math.PI/180;
				createTrain( toyTrain, ttCompt_01, ttCompt_02 );
				scene.add( toyTrain );
				scene.add( ttCompt_01 );
				scene.add( ttCompt_02 );

				//Sky
				addSkyDome();
				// Stars
				addStars();
				addSmoke();
				
			}

			function addToDOM() {
				var container = document.getElementById('container');
				var canvas = container.getElementsByTagName('canvas');
				if (canvas.length>0) {
					container.removeChild(canvas[0]);
				}
				container.appendChild( renderer.domElement );
			}

			function animate() {

				window.requestAnimationFrame( animate );
				render();

			}

			function render() {
				var delta = clock.getDelta();
				cameraControls.update(delta);
				
				toyTrain.rotation.y += 0.5*Math.PI/180;
				toyTrain.rotation.z = (Math.random()*1.1)*Math.PI/180;

				ttCompt_01.rotation.y += (0.5*Math.PI/180);
				ttCompt_01.rotation.z = (Math.random()*1.1)*Math.PI/180;

				ttCompt_02.rotation.y += (0.5*Math.PI/180);
				ttCompt_02.rotation.z = (Math.random()*1.1)*Math.PI/180;
				
				for ( var c = 0; c < particleGroup.children.length; c ++ ) {

					var sprite = particleGroup.children[ c ];
					var scale = Math.sin( delta * 1000 ) * (Math.random()*10) + 40.0;
					sprite.scale.set( scale, scale, 1.0);
				}
				
				var particleCount = smokeParticles.vertices.length;
				while (particleCount--) {
					var particle = smokeParticles.vertices[particleCount];
    					particle.y += delta * 150;
					particle.x -= delta * 40;
					//particle.x -= Math.smoothstep(1.0,0.0,40.0);
     
    					if (particle.y >= 230) {
        					particle.y = Math.random() * 15;
        					particle.x = Math.random() * 30 - 15;
        					particle.z = Math.random() * 30 - 15;
    					}
				}
				smokeParticles.__dirtyVertices = true;

				headlight.position.copy(camera.position);
				
				if ( effectController.newGridX !== gridX || effectController.newGridY !== gridY ||effectController.newGridZ !== gridZ || effectController.newGround !== ground || effectController.newAxes !== axes)
				{
					gridX = effectController.newGridX;
					gridY = effectController.newGridY;
					gridZ = effectController.newGridZ;
					ground = effectController.newGround;
					axes = effectController.newAxes;

					fillScene();
					drawHelpers();
				}
				renderer.render( scene, camera );
			}

			function drawHelpers() {
				if (ground) {
					Coordinates.drawGround({size:10000});
				}
				if (gridX) {
					Coordinates.drawGrid({size:10000,scale:0.01});
				}
				if (gridY) {
					Coordinates.drawGrid({size:10000,scale:0.01, orientation:"y"});
				}
				if (gridZ) {
					Coordinates.drawGrid({size:10000,scale:0.01, orientation:"z"});
				}
				if (axes) {
					Coordinates.drawAllAxes({axisLength:200,axisRadius:1,axisTess:50});
				}
			}

			function setupGui() {
				effectController = {

					newGridX: gridX,
					newGridY: gridY,
					newGridZ: gridZ,
					newGround: ground,
					newAxes: axes
				};
				var gui = new dat.GUI();
				gui.add( effectController, "newGridX").name("Show XZ grid");
				gui.add( effectController, "newGridY" ).name("Show YZ grid");
				gui.add( effectController, "newGridZ" ).name("Show XY grid");
				gui.add( effectController, "newGround" ).name("Show ground");
				gui.add( effectController, "newAxes" ).name("Show axes");
			}
			try {
				init();
				fillScene();
				setupGui();
				drawHelpers();
				addToDOM();
				animate();
			} catch(e) {
				var errorReport = "Your program encountered an unrecoverable error, can not draw on canvas. Error was:<br/><br/>";
				//$('#container').append(errorReport+e);
			}

		</script>
	</body>
</html>
